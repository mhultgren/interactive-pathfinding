<!DOCTYPE html>
<html>
<head>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>

    <div class="header">
        <h1>Converting Real Problems to Problem Spaces</h1>
        <p class="text-muted">Joey Rose &amp; Myles Hultgren</p>
    </div>

    <div>
        <div class="newSection">
            <div class="header">
                <h2>Introduction</h2>
            </div>
            <p>
                Pathfinding algorithms are algorithms that efficiently find paths between entities in a graph, and were created to solve problems in a wide array of fields. We use pathfinding in our navigation, finding the quickest route to the convenience store three miles away. We use pathfinding in our videogames, creating realistic AI with complex decision making capabilities. We use pathfinding to solve puzzles, commonly mazes, but others as well. We might even use pathfinding to solve pesky Leetcode questions in a job interview. 
            </p>
            <p>
                While typical computer science coursework devotes a substantial amount of time toward teaching these algorithms, often little time is spent applying them to real world problems. In this article we will investigate three problems which can be solved with pathfinding, giving you the opportunity to learn more through interaction.
            </p>
            <p>
                Before we investigate each application, however, let us revisit the concept of graphs and the common pathfinding algorithms we will be referring to in this article.
            </p>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h3>Graphs</h3>
            </div>
            <p>
                A graph is a data structure where data is stored in a collection of interconnected vertices (nodes) and paths (edges). The ways in which nodes are connected by edges determines the type of graph as well. If the edges have a “cost” or “weight” associated with them, the graph is considered weighted rather than unweighted. In addition, if edges connect nodes in both directions, the graph is referred to as undirected as opposed to directed. Lastly, in a directed graph, if edges connect nodes in a loop of any size, the graph is classified as cyclic instead of acyclic. 
            </p>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h3>Breadth-First Search (BFS)</h3>
            </div>

            <p>
                One of the most common pathfinding algorithms, Breadth First Search uses a queue to examine each neighbor of the source node before arriving at its destination. Starting at the source node, BFS checks each neighbor before moving on to each neighbor of those neighbors in turn, expanding outwards equally in all directions from the source as it searches.
            </p>
            <p>
                BFS guarantees the shortest path from source to destination in an unweighted graph, albeit in a fairly inefficient manner.
            </p>  
            <p>  
                Interact with the dropdown to see an example of the BFS in action. Watch as it examines each neighbor in turn before expanding outwards!
            </p>
            <div>
                <form onsubmit="show_video(this); return false;" class="form-inline">
                    <label for="intro-bfs">Choose an algorithm:</label>
                    <div style="display: flex;">
                        <select class="form-select form-select-lg" id="intro-bfs" name="intro-bfs">
                            <option value = "">No thanks</option>
                            <option value = "intro_bfs.mp4">Breadth-First</option>
                        </select>
                        <button class="selectButton btn btn-outline-dark" type="submit">Submit</button>
                    </div>
                </form>
                <video autoplay loop muted width="500" height="300" style="display: none;"></video>
            </div>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h3>Depth-First Search (DFS)</h3>
            </div>

            <p>
                While BFS expands in all directions as it searches, Depth First Search algorithms use a stack to search as far as possible down one path, backtracking when a node with no more neighbors is reached. Starting at the source node, DFS examines each neighbor as far as it can go, before moving on to the next neighbor of the source node.        
            </p>
            <p>
                Unlike BFS, DFS does not guarantee the shortest path. However, it can be the preferred algorithm for larger graphs where the destination node is likely to be far from the source node, as fewer nodes can be visited in the process.
            </p>  
            <p>  
                Below is the same example, this time of the DFS. Note how it finishes each path before checking the path of neighboring nodes.
            </p>
            <div>
                <form onsubmit="show_video(this); return false;">
                    <label for="intro-dfs">Choose an algorithm:</label>
                    <div style="display: flex;">
                        <select class="form-select form-select-lg" id="intro-dfs" name="intro-bfs">
                            <option value = "">No thanks</option>
                            <option value = "intro_dfs.mp4">Depth-First</option>
                        </select>
                        <button class="selectButton btn btn-outline-dark" type="submit">Submit</button>
                    </div>
                </form>
                <video autoplay loop muted width="500" height="300" style="display: none;"></video>
            </div>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h3>Dijkstra's Algorithm</h3>
            </div>
            <p>
                Created in 1956 by Edsger Dijkstra, Dijkstra’s algorithm uses a priority queue to find the shortest path. Dijkstra’s priority queue consists of paths ranked by their total cost, or the sum of all the edge weights that make up the path, such that the path with the minimum total cost exists at the top of the queue. By prioritizing visiting nodes that minimize overall cost, Dijkstra’s algorithm ensures that the path of lowest cost is always being dealt with, thus guaranteeing a shortest path. Dijkstra’s algorithm excels when used with weighted graphs, where edge weights distinguish shortest paths from shortest paths in the euclidean sense.
            <p>
            <p>  
                One thing to keep in mind is that, due to the priority queue requiring reordering when adding a new node to the queue, Dijkstra’s algorithm has added time complexity in that regard.
            </p>
            <p>Check out what it looks like here!</p>
            <div>
                <form onsubmit="show_video(this); return false;">
                    <label for="intro-dijkstras">Choose an algorithm:</label>
                    <div style="display: flex;">
                        <select class="form-select form-select-lg" id="intro-dijkstras" name="intro-bfs">
                            <option value = "">No thanks</option>
                            <option value = "intro_dijkstras.mp4">Dijkstra’s algorithm</option>
                        </select>
                        <button class="selectButton btn btn-outline-dark" type="submit">Submit</button>
                    </div>
                </form>
                <video autoplay loop muted width="500" height="300" style="display: none;"></video>
            </div>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h3>A* Algorithm</h3>
            </div>

            <p>
                The A* algorithm builds on top of Dijkstra’s algorithm, taking both total path cost and the distance of a node from the destination node into account when adding new paths to the priority queue.
            <p>
            <p>  
                By doing so, A* ensures that the shortest path that approaches the destination node is taken into account, usually requiring the examination of fewer nodes. However, because the distance from the destination heuristic may not be applicable to all types of problems, A* may not be an appropriate algorithm in all cases.
            </p>
            <p>Check out what it looks like here!</p>
            <div>
                <form onsubmit="show_video(this); return false;">
                    <label for="intro-A_">Choose an algorithm:</label>
                    <div style="display: flex;">
                        <select class="form-select form-select-lg" id="intro-A_" name="intro-bfs">
                            <option value = "">No thanks</option>
                            <option value = "intro_A*.mp4">A* algorithm</option>
                        </select>
                        <button class="selectButton btn btn-outline-dark" type="submit">Submit</button>
                    </div>
                </form>
                <video autoplay loop muted width="500" height="300" style="display: none;"></video>
            </div>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h2>Real world examples</h2>
            </div>

            <p>
                Now that the four algorithms have been introduced, it is time we move on to consider some real world examples in which these algorithms can be used.
            </p>
            <p>
                Note: problems and algorithms were modeled using Clement Mihailescu’s Pathfinding Visualizer tool, available <a href="https://clementmihailescu.github.io/Pathfinding-Visualizer/#">here</a>.
            </p>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection loadingElement">
            <div class="header">
                <h1>Sliding Block Puzzles</h1>
            </div>

            <p>
                One example of a problem that can be solved via pathfinding algorithms is a sliding-puzzle game! In this game, players receive an NxN board randomly populated with tiles numbered 1 - (N^2), and are tasked with sliding pieces along certain routes to establish a certain end-configuration. See for yourself what it’s like on a 3x3 board!
            </p>

            <iframe name='proprofs' id='proprofs' height='625' width='770px' style='overflow-x: hidden;' frameborder=0 marginwidth=0 marginheight=0 src='https://www.proprofsgames.com/puzzle/sliding/mona-lisaq/?ew=500' onload="let_iframe_load_before_hiding(this)"></iframe>
            <p>
                While this may not seem solvable using pathfinding at first glance, let us consider how we might leverage existing algorithms to find a working solution.
            </p>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "hiddenElement">
            <h4>Quiz</h4>
            <form id = "q1" onsubmit="check_answer(this); return false;">
                <p>Sliding block puzzles can be thought of as a graph problem</p>
                <input type="radio" id="q1ans1" name = "question1">
                <label for="q1ans1">True</label><br>

                <input type="radio" id="q1ans2" name = "question1">
                <label for="q1ans2">False</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>

        <div class = "hiddenElement">
            <form id = "q2" onsubmit="check_answer(this); return false;">
                <p>What would the nodes and edges be?</p>
                <input type="radio" id="q2ans1" name = "question2">
                <label for="q2ans1">Nodes are the leftover spaces, and edges are the remaining tiles</label><br>

                <input type="radio" id="q2ans2" name = "question2">
                <label for="q2ans2">Nodes are boards, edges connect boards differing by one move</label><br>

                <input type="radio" id="q2ans3" name = "question2">
                <label for="q2ans3">Nodes are tiles in a board, edges connect one tile to another</label><br>

                <input type="radio" id="q2ans4" name = "question2">
                <label for="q2ans4">None of the above</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>
        <div class = "hiddenElement">
            <form id = "q3" onsubmit="check_answer(this); return false;">
                <p>How many neighbors would a node have?</p>
                <input type="radio" id="q3ans1" name = "question3">
                <label for="q3ans1">It depends on the size of the board</label><br>

                <input type="radio" id="q3ans2" name = "question3">
                <label for="q3ans2">4</label><br>

                <input type="radio" id="q3ans3" name = "question3">
                <label for="q3ans3">Between 2 and 4</label><br>

                <input type="radio" id="q3ans4" name = "question3">
                <label for="q3ans4">2</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>
        <div class = "hiddenElement">
            <h3>How the algorithm would affect problem solving</h3>
            <p>
                In these visualizations, each cell represents an entire board. The asterisk symbolizes the starting board while the target represents the finished, solved board. So, as the algorithm visits each neighbor, think of it as reaching a new board after moving a piece.
            </p>
            <div>
                <form onsubmit="show_video(this); return false;">
                    <label for="example1visuals">Choose an algorithm:</label>
                    <div style="display: flex;">
                        <select class="form-select form-select-lg" id="example1visuals" name="example1visuals">
                            <option value = "">No thanks</option>
                            <option value = "example1_bfs.mp4">Breadth-First</option>
                            <option value = "example1_dfs.mp4">Depth-First</option>
                            <option value = "example1_dijkstras.mp4">Dijkstra's</option>
                        </select>
                        <button class="selectButton btn btn-outline-dark" type="submit">Submit</button>
                    </div>
                </form>
                <video autoplay loop muted width="500" height="300" style="display: none;"></video>
            </div>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "hiddenElement">
            <p>
                In these visualizations, we can see how different approaches work to find the best route. Because the graph space for game boards is unweighted, approaches using breadth-first search and dijkstra’s become almost indistinguishable. On the other hand, a depth-first search based approach clearly does not find the minimal moves necessary to reach the destination node. Lastly, A* is not even applicable here since a heuristic based on distance from the end board would not make much sense.
            </p>

            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h1>Routing and Navigation</h1>
            </div>

                <p>
                    If you have ever been lost or in need of directions, you will recognize the value of mapping systems like Google Maps in providing the fastest routes from point A to point B. While it may not seem like it, this technology can be boiled down to a pathfinding problem, and solved using the algorithms you know! In this example, we ask of you to frame this real world problem in such a manner.
                </p>

                <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>
        <div class = "hiddenElement">
            <h4>Quiz</h4>
            <form id = "q4" onsubmit="check_answer(this); return false;">
                <p>Routing problems should always be implemented with unweighted graphs</p>
                <input type="radio" id="q4ans1" name = "question4">
                <label for="q4ans1">True</label><br>

                <input type="radio" id="q4ans2" name = "question4">
                <label for="q4ans2">False</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>

        <div class = "hiddenElement">
            <form id = "q5" onsubmit="check_answer(this); return false;">
                <p>What would the nodes and edges be for a typical routing problem?</p>
                <input type="radio" id="q5ans1" name = "question5">
                <label for="q5ans1">Nodes are intersections, edges are connections between intersections</label><br>

                <input type="radio" id="q5ans2" name = "question5">
                <label for="q5ans2">Nodes are different areas of interest, edges are roads connecting each area</label><br>

                <input type="radio" id="q5ans3" name = "question5">
                <label for="q5ans3">Nodes are all walkable/bikeable paths, edges are connections between paths</label><br>

                <input type="radio" id="q5ans4" name = "question5">
                <label for="q5ans4">None of the above</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>

        <div class = "hiddenElement">
            <form id = "q6" onsubmit="check_answer(this); return false;">
                <p>What would a useful heuristic be for this problem?</p>
                <input type="radio" id="q6ans1" name = "question6">
                <label for="q6ans1">Distance from source to node</label><br>

                <input type="radio" id="q6ans2" name = "question6">
                <label for="q6ans2">Distance from node to destination</label><br>

                <input type="radio" id="q6ans3" name = "question6">
                <label for="q6ans3">Both the first and second answers</label><br>

                <input type="radio" id="q6ans4" name = "question6">
                <label for="q6ans4">No heuristic necessary</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>

        <div class = "hiddenElement">
            <h3>How the algorithm would affect problem solving</h3>
            <div>
                <form onsubmit="show_video(this); return false;">
                    <label for="example2visuals">Choose an algorithm:</label>
                    <div style="display: flex;">
                        <select class="form-select form-select-lg" id="example2visuals" name="example2visuals">
                            <option value = "">No thanks</option>
                            <option value = "example2_bfs.mp4">Breadth-First</option>
                            <option value = "example2_dfs.mp4">Depth-First</option>
                            <option value = "example2_dijkstras.mp4">Dijkstra's</option>
                            <option value = "example2_A*.mp4">A*</option>
                        </select>
                        <button class="selectButton btn btn-outline-dark" type="submit">Submit</button>
                    </div>
                </form>
                <video autoplay loop muted width="500" height="300" style="display: none;"></video>
            </div>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "hiddenElement">
            <p>
                In these visualizations, we can see how different approaches work to find the best route. Because traffic and other factors can render some streets slower than others for transportation, graphs are always weighted for these problems. Because Dijkstra’s and A* take total path cost into account, they excel at finding the quickest route from point A to point B. Nevertheless, because A* can take into account distance from the destination node as well, it finds the shortest path more efficiently than the other algorithms.
            </p>

            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h1>Progression of a System Over Time</h1>
            </div>

                <p>
                    Have you ever wondered what would happen if you let moldy food continue to take its course? If you knew the daily rate of progression, how long would it take for it to be completely moldy? This phenomenon embodies the progression of a system over time, and can be framed as a problem amenable by graph algorithms.
                </p>

                <p>
                    In the Leetcode question <a href="https://leetcode.com/problems/rotting-oranges/">Rotting Oranges</a>, the user must develop an algorithm to model the spread of rottenness from one orange to another. Given a graph of m columns by n rows filled with the numbers 0-2 (where 0 is an empty space, 1 is a fresh orange, and 2 is a rotten orange), the user must calculate how many minutes it will take for every orange to become rotten. Every minute, each rotten orange infects every orange above it, below it, or to either side. The program returns -1 if it is impossible for all oranges to become rotten (not within the radius of any rotten oranges), otherwise it returns the number of minutes elapsed before every orange is rotten. Think about how you would transform this into a problem space!
                </p>

                <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>
        <div class = "hiddenElement">
            <h4>Quiz</h4>
            <form id = "q7" onsubmit="check_answer(this); return false;">
                <p>The best heuristic for this problem would be</p>
                <input type="radio" id="q7ans1" name = "question7">
                <label for="q7ans1">Distance from rotten orange to fresh orange</label><br>

                <input type="radio" id="q7ans2" name = "question7">
                <label for="q7ans2">Number of fresh oranges neighboring node</label><br>

                <input type="radio" id="q7ans3" name = "question7">
                <label for="q7ans3">Distance from fresh orange to rotten orange</label><br>

                <input type="radio" id="q7ans4" name = "question7">
                <label for="q7ans4">No heuristic at all</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>

        <div class = "hiddenElement">
            <form id = "q8" onsubmit="check_answer(this); return false;">
                <p>How many neighbors would a node have?</p>
                <input type="radio" id="q8ans1" name = "question8">
                <label for="q8ans1">Depends on the rate of progression</label><br>

                <input type="radio" id="q8ans2" name = "question8">
                <label for="q8ans2">Depends on the size of the graph</label><br>

                <input type="radio" id="q8ans3" name = "question8">
                <label for="q8ans3">Number of nodes / number of edges</label><br>

                <input type="radio" id="q8ans4" name = "question8">
                <label for="q8ans4">None of the above</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>

        <div class = "hiddenElement">
            <form id = "q9" onsubmit="check_answer(this); return false;">
                <p>Which algorithm is most suitable for this problem?</p>
                <input type="radio" id="q9ans1" name = "question9">
                <label for="q9ans1">Dijkstra’s</label><br>

                <input type="radio" id="q9ans2" name = "question9">
                <label for="q9ans2">Breadth-first search</label><br>

                <input type="radio" id="q9ans3" name = "question9">
                <label for="q9ans3">Depth-first search</label><br>

                <input type="radio" id="q9ans4" name = "question9">
                <label for="q9ans4">Any of the above</label><br>

                <button class="btn btn-outline-dark" type="submit">Submit</button>
                <i class="fa fa-check" aria-hidden="true" style="color: green; display: none;"></i>
                <i class="fa fa-times" aria-hidden="true" style="color: red; display: none;"></i>
            </form>
        </div>

        <div class = "hiddenElement">
            <h3>How the algorithm would affect problem solving</h3>
            <div>
                <form onsubmit="show_video(this); return false;">
                    <label for="example3visuals">Choose an algorithm:</label>
                    <div style="display: flex;">
                        <select class="form-select form-select-lg" id="example3visuals" name="example3visuals">
                            <option value = "">No thanks</option>
                            <option value = "example3_bfs.mp4">Breadth-First</option>
                            <option value = "example3_dijkstras.mp4">Dijkstra's</option>
                        </select>
                        <button class="selectButton btn btn-outline-dark" type="submit">Submit</button>
                    </div>
                </form>
                <video autoplay loop muted width="500" height="300" style="display: none;"></video>
            </div>
            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "hiddenElement">
            <p>
                In these visualizations, we can see how different approaches work to solve the problem. Unlike the other problems, only breadth-first search and Dijkstra’s algorithm work here, since they’re the only ones that traverse a graph in an even fashion (since the graph is unweighted for this problem). Despite sharing similar traversal patterns for this problem, it makes much more sense to approach this problem with breadth-first search given its simpler implementation and lack of reliance on a priority queue, which adds additional time complexity.
            </p>

            <button class="btn btn-outline-dark btn-sm continueButton" onclick="reveal_or_hide_next_div(this.parentElement.nextElementSibling, true)">Continue</button>
        </div>

        <div class = "newSection hiddenElement">
            <div class="header">
                <h1>Conclusion</h1>
            </div>

            <p>
                We know this has been a lot of information, but we hope that you have been able to come away with more knowledge concerning the potential implementations of pathfinding algorithms, as well as the benefits and drawbacks of each. Being a strong programmer does not only mean a knowledge of math or constant reading of documentation, but knowledge of useful algorithms and when to use them. If you ever find yourself stuck on a nasty coding problem, floundering in a coding interview or rushing to push code before midnight, keep in mind the algorithms introduced here. They might just come in handy!
            </p>
        </div>
    </div>
    <script>
        let form_id_to_correct_answer_id = 
        {
        "q1": "q1ans1",
        "q2": "q2ans2",
        "q3": "q3ans3",
        "q4": "q4ans2",
        "q5": "q5ans1",
        "q6": "q6ans2",
        "q7": "q7ans4",
        "q8": "q8ans4",
        "q9": "q9ans2"
        };

        function let_iframe_load_before_hiding(event) {
            event.parentElement.classList.add("hiddenElement");
            event.parentElement.classList.remove("loadingElement");
        };

        function show_video (event) {
            let video_name = event.getElementsByTagName("select")[0].value;

            console.log("video name is " + video_name);

            let video_elem = event.nextElementSibling;
            // if there's no value, make sure next sibling's display is none
            if (video_name == "") video_elem.style.display = "none";

            // else, make display visible and show proper video
            else {
                video_elem.setAttribute("src", video_name);
                video_elem.load();
                video_elem.style.display = "block";
            }

        }
        function check_answer (event) {
            console.log(event.id);
            // if answer is correct, keep showing next parts of the page up until latest point
            let correct_answer_id = form_id_to_correct_answer_id[event.id];

            let error_icon = document.getElementById(event.id).getElementsByClassName("fa fa-times")[0];
            let success_icon = document.getElementById(event.id).getElementsByClassName("fa fa-check")[0];

            let next_div = event.parentElement.nextElementSibling;

            if (document.getElementById(correct_answer_id).checked) {
                console.log("correct answer!")
                error_icon.style.display = "none";
                success_icon.style.display = "inline-block";

                reveal_or_hide_next_div(next_div, true);

            }
            // else, keep removing next parts of the page up until latest point
            else {
                console.log("wrong answer!")
                error_icon.style.display = "inline-block";
                success_icon.style.display = "none";

                reveal_or_hide_next_div(next_div, false)
            }
        }

        function reveal_or_hide_next_div (next_div, reveal) {
            console.log("revealing or hiding");
            console.log(next_div);
            while (next_div != null && next_div.getElementsByClassName("fa fa-check").length > 0) {
                if (next_div.getElementsByClassName("fa fa-check")[0].style.display != "inline-block") break;

                if (reveal == true) next_div.classList.add("revealedElement");
                else next_div.classList.remove("revealedElement");
                next_div = next_div.nextElementSibling;
            }
            if (next_div != null) {
                if (reveal == true) next_div.classList.add("revealedElement");
                else next_div.classList.remove("revealedElement");
            }
            window.scrollTo(0,document.body.scrollHeight);
        }
    </script>
</body>
</html>
